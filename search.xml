<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis 传入多个参数配置]]></title>
    <url>%2F2018%2F10%2F18%2FMybatis-%E4%BC%A0%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文对Mybatis如何传入参数进行一个简单的说明 一、单个参数：1234567public List&lt;XXBean&gt; getXXBeanList(String xxCode); &lt;select id="getXXXBeanList" parameterType="java.lang.String" resultType="XXBean"&gt; select t.* from tableName t where t.id= #&#123;id&#125; &lt;/select&gt; 其中方法名和ID一致，#{}中的参数名与方法中的参数名一直， 我这里采用的是XXXBean是采用的短名字, select 后的字段列表要和bean中的属性名一致， 如果不一致的可以用 as 来补充。 二、多参数：123456789public List&lt;XXXBean&gt; getXXXBeanList(String xxId, String xxCode); &lt;select id="getXXXBeanList" resultType="XXBean"&gt; select t.* from tableName where id = #&#123;0&#125; and name = #&#123;1&#125; &lt;/select&gt; 由于是多参数那么就不能使用parameterType， 改用#｛index｝是第几个就用第几个的索引，索引从0开始 三、Map封装多参数：1234567public List&lt;XXXBean&gt; getXXXBeanList(HashMap map); &lt;select id="getXXXBeanList" parameterType="hashmap" resultType="XXBean"&gt; select 字段... from XXX where id=#&#123;xxId&#125; code = #&#123;xxCode&#125; &lt;/select&gt; 其中hashmap是mybatis自己配置好的直接使用就行。map中key的名字是那个就在#{}使用那个，map如何封装就不用了我说了吧。 四、List封装in：12345678public List&lt;XXXBean&gt; getXXXBeanList(List&lt;String&gt; list); &lt;select id="getXXXBeanList" resultType="XXBean"&gt; select 字段... from XXX where id in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt; foreach 最后的效果是select 字段… from XXX where id in (‘1’,’2’,’3’,’4’) 五、多参数传递之注解方式示：例子： 1public AddrInfo getAddrInfo(@Param("corpId")int corpId, @Param("addrId")int addrId); xml配置这样写： 1234&lt;select id="getAddrInfo" resultMap="com.xxx.xxx.AddrInfo"&gt; SELECT * FROM addr__info where addr_id=#&#123;addrId&#125; and corp_id=#&#123;corpId&#125;&lt;/select&gt; 以前在语句中要带parameterType的，现在可以不要这样写。 六、selectList()只能传递一个参数，但实际所需参数既要包含String类型，又要包含List类型时的处理方法:将参数放入Map，再取出Map中的List遍历。如下： 1234567891011121314List&lt;String&gt; list_3 = new ArrayList&lt;String&gt;();Map&lt;String, Object&gt; map2 = new HashMap&lt;String, Object&gt;();list.add("1");list.add("2");map2.put("list", list); //网址idmap2.put("siteTag", "0");//网址类型 public List&lt;SysWeb&gt; getSysInfo(Map&lt;String, Object&gt; map2) &#123; return getSqlSession().selectList("sysweb.getSysInfo", map2);&#125; 12345678910&lt;select id="getSysInfo" parameterType="java.util.Map" resultType="SysWeb"&gt; select t.sysSiteId, t.siteName, t1.mzNum as siteTagNum, t1.mzName as siteTag, t.url, t.iconPath from TD_WEB_SYSSITE t left join TD_MZ_MZDY t1 on t1.mzNum = t.siteTag and t1.mzType = 10 WHERE t.siteTag = #&#123;siteTag &#125; and t.sysSiteId not in &lt;foreach collection="list" item="item" index="index" open="(" close=")" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>参数配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo图床的设置(七牛云+vscode插件)]]></title>
    <url>%2F2018%2F09%2F20%2Fhexo%E5%9B%BE%E5%BA%8A%E7%9A%84%E8%AE%BE%E7%BD%AE-%E4%B8%83%E7%89%9B%E4%BA%91-vscode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言最近在电脑上装了Typora，虽然Typora写MD很方便，但是由于我写的MD主要以个人的hexo为主，在上传图片的就比较繁琐，同时直接上图片上传到博客工程也不合理，当图片多了容易占用空间。所以打算以七牛云作为图床并配合VSCode插件简化图片插入的步骤。 过程 注册七牛云接着在新建对象存储。这里会有一个默认的【测试域名】，如果你的网站还没有备案的话，就用这个默认的吧。备案了的可以自定义域名。 配置VSCode过程 依次打开【文件】-【首选项】-【设置】在【搜索设置】中搜索qiniu关键字将【qiniu configuration】中的6个子设置从【默认设置】拷贝到【用户设置】其中的【AccessKey 签名授权】【SecretKey 签名授权】在密钥管理七牛图片上传空间是你的存储空间的名字，七牛图床域名为测试域名。接着还想在VSCode里面直接完成部署功能。有两种方法： 安装vscode-Hexo插件 然后直接在命令面板中输入以下命令： 按住Ctrl+` 在VSCode中弹出终端，也可以在这里面直接输入命令操作。]]></content>
      <categories>
        <category>hexo配置及使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>七牛云</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点]]></title>
    <url>%2F2018%2F09%2F20%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[\(≧▽≦)/ 密码呢！！！ Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList实现原理]]></title>
    <url>%2F2018%2F09%2F19%2FLinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概要前面，我们已经学习了ArrayList，并了解了fail-fast机制。这一章我们接着学习List的实现类——LinkedList。和学习ArrayList一样，接下来呢，我们先对LinkedList有个整体认识，然后再学习它的源码；最后再通过实例来学会使用LinkedList。 本文转载自：http://www.cnblogs.com/skywang12345/p/3308807.html 第1部分 LinkedList介绍LinkedList简介 LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList 实现 List 接口，能对它进行队列操作。LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。LinkedList 是非同步的。 LinkedList构造函数 12345// 默认构造函数LinkedList()// 创建一个LinkedList，保护Collection中的全部元素。LinkedList(Collection&lt;? extends E&gt; collection) LinkedList的API 12345678910111213141516171819202122232425262728293031323334353637383940LinkedList的APIboolean add(E object)void add(int location, E object)boolean addAll(Collection&lt;? extends E&gt; collection)boolean addAll(int location, Collection&lt;? extends E&gt; collection)void addFirst(E object)void addLast(E object)void clear()Object clone()boolean contains(Object object)Iterator&lt;E&gt; descendingIterator()E element()E get(int location)E getFirst()E getLast()int indexOf(Object object)int lastIndexOf(Object object)ListIterator&lt;E&gt; listIterator(int location)boolean offer(E o)boolean offerFirst(E e)boolean offerLast(E e)E peek()E peekFirst()E peekLast()E poll()E pollFirst()E pollLast()E pop()void push(E e)E remove()E remove(int location)boolean remove(Object object)E removeFirst()boolean removeFirstOccurrence(Object o)E removeLast()boolean removeLastOccurrence(Object o)E set(int location, E object)int size()&lt;T&gt; T[] toArray(T[] contents)Object[] toArray() AbstractSequentialList简介 在介绍LinkedList的源码之前，先介绍一下AbstractSequentialList。毕竟，LinkedList是AbstractSequentialList的子类。 AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。 此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。 第2部分 LinkedList数据结构LinkedList的继承关系 123456789java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.AbstractSequentialList&lt;E&gt; ↳ java.util.LinkedList&lt;E&gt;public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125; LinkedList与Collection关系如下图： LinkedList的本质是双向链表。(01) LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。(02) LinkedList包含两个重要的成员：header 和 size。 header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。 size是双向链表中节点的个数。 第3部分 LinkedList源码解析(基于JDK1.6.0_45)为了更了解LinkedList的原理，下面对LinkedList源码代码作出分析。 在阅读源码之前，我们先对LinkedList的整体实现进行大致说明：​ LinkedList实际上是通过双向链表去实现的。既然是双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低。​ 既然LinkedList是通过双向链表的，但是它也实现了List接口{也就是说，它实现了get(int location)、remove(int location)等“根据**索引值**来获取、删除节点的函数”}。LinkedList是如何实现List的这些接口的，如何将“双向链表和索引值联系起来的”？​ 实际原理非常简单，它就是通过一个计数索引值来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置。 这就是“双线链表和索引值联系起来”的方法。 好了，接下来开始阅读源码(只要理解双向链表，那么LinkedList的源码很容易理解的)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639package java.util;public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() &#123; header.next = header.previous = header; &#125; // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; // 获取LinkedList的第一个元素 public E getFirst() &#123; if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; &#125; // 获取LinkedList的最后一个元素 public E getLast() &#123; if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; &#125; // 删除LinkedList的第一个元素 public E removeFirst() &#123; return remove(header.next); &#125; // 删除LinkedList的最后一个元素 public E removeLast() &#123; return remove(header.previous); &#125; // 将元素添加到LinkedList的起始位置 public void addFirst(E e) &#123; addBefore(e, header.next); &#125; // 将元素添加到LinkedList的结束位置 public void addLast(E e) &#123; addBefore(e, header); &#125; // 判断LinkedList是否包含元素(o) public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; // 返回LinkedList的大小 public int size() &#123; return size; &#125; // 将元素(E)添加到LinkedList中 public boolean add(E e) &#123; // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; &#125; // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) &#123; if (o==null) &#123; // 若o为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // 若o不为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) &#123; Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; &#125; successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; &#125; // 清空双向链表 public void clear() &#123; Entry&lt;E&gt; e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) &#123; Entry&lt;E&gt; next = e.next; e.next = e.previous = null; e.element = null; e = next; &#125; header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; &#125; // 返回LinkedList指定位置的元素 public E get(int index) &#123; return entry(index).element; &#125; // 设置index位置对应的节点的值为element public E set(int index, E element) &#123; Entry&lt;E&gt; e = entry(index); E oldVal = e.element; e.element = element; return oldVal; &#125; // 在index前添加节点，且节点的值为element public void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index))); &#125; // 删除index位置的节点 public E remove(int index) &#123; return remove(entry(index)); &#125; // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e; &#125; // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) &#123; int index = 0; if (o==null) &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (e.element==null) return index; index++; &#125; &#125; else &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) return index; index++; &#125; &#125; return -1; &#125; // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) &#123; int index = size; if (o==null) &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (e.element==null) return index; &#125; &#125; else &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (o.equals(e.element)) return index; &#125; &#125; return -1; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() &#123; if (size==0) return null; return getFirst(); &#125; // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() &#123; return getFirst(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() &#123; if (size==0) return null; return removeFirst(); &#125; // 将e添加双向链表末尾 public boolean offer(E e) &#123; return add(e); &#125; // 将e添加双向链表开头 public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; // 将e添加双向链表末尾 public boolean offerLast(E e) &#123; addLast(e); return true; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() &#123; if (size==0) return null; return getFirst(); &#125; // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() &#123; if (size==0) return null; return getLast(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() &#123; if (size==0) return null; return removeFirst(); &#125; // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() &#123; if (size==0) return null; return removeLast(); &#125; // 将e插入到双向链表开头 public void push(E e) &#123; addFirst(e); &#125; // 删除并返回第一个节点 public E pop() &#123; return removeFirst(); &#125; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) &#123; if (o==null) &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; // List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) &#123; // index的有效性处理 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; &#125; else &#123; next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; &#125; &#125; // 是否存在下一个元素 public boolean hasNext() &#123; // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; &#125; // 获取下一个元素 public E next() &#123; checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; &#125; // 是否存在上一个元素 public boolean hasPrevious() &#123; // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; &#125; // 获取上一个元素 public E previous() &#123; if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; &#125; // 获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; // 获取上一个元素的索引 public int previousIndex() &#123; return nextIndex-1; &#125; // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() &#123; checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try &#123; LinkedList.this.remove(lastReturned); &#125; catch (NoSuchElementException e) &#123; throw new IllegalStateException(); &#125; if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; &#125; // 设置当前节点为e public void set(E e) &#123; if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; &#125; // 将e添加到当前节点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; &#125; // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) &#123; if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; &#125; // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; // 反向迭代器实现类。 private class DescendingIterator implements Iterator &#123; final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() &#123; return itr.hasPrevious(); &#125; // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() &#123; return itr.previous(); &#125; // 删除当前节点 public void remove() &#123; itr.remove(); &#125; &#125; // 返回LinkedList的Object[]数组 public Object[] toArray() &#123; // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; &#125; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; &#125; // 克隆函数。返回LinkedList的克隆对象。 public Object clone() &#123; LinkedList&lt;E&gt; clone = null; // 克隆一个LinkedList克隆对象 try &#123; clone = (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; &#125; // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); &#125; // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); &#125;&#125; 总结：(01) LinkedList 实际上是通过双向链表去实现的。​ 它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。(02) 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。(03) LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。(04) LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。(05) 由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。 总结起来如下表格： 12345 第一个元素（头部） 最后一个元素（尾部） 抛出异常 特殊值 抛出异常 特殊值插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e)移除 removeFirst() pollFirst() removeLast() pollLast()检查 getFirst() peekFirst() getLast() peekLast() (06) LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价： 1234567队列方法 等效方法add(e) addLast(e)offer(e) offerLast(e)remove() removeFirst()poll() pollFirst()element() getFirst()peek() peekFirst() (07) LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价： 1234栈方法 等效方法push(e) addFirst(e)pop() removeFirst()peek() peekFirst() 第4部分 LinkedList遍历方式LinkedList遍历方式 LinkedList支持多种遍历方式。建议不要采用随机访问的方式去遍历LinkedList，而采用逐个遍历的方式。(01) 第一种，通过迭代器遍历。即通过Iterator去遍历。 12for(Iterator iter = list.iterator(); iter.hasNext();) iter.next(); (02) 通过快速随机访问遍历LinkedList 1234int size = list.size();for (int i=0; i&lt;size; i++) &#123; list.get(i); &#125; (03) 通过另外一种for循环来遍历LinkedList 12for (Integer integ:list) ; (04) 通过pollFirst()来遍历LinkedList 12while(list.pollFirst() != null) ; (05) 通过pollLast()来遍历LinkedList 12while(list.pollLast() != null) ; (06) 通过removeFirst()来遍历LinkedList 12345try &#123; while(list.removeFirst() != null) ;&#125; catch (NoSuchElementException e) &#123;&#125; (07) 通过removeLast()来遍历LinkedList 12345try &#123; while(list.removeLast() != null) ;&#125; catch (NoSuchElementException e) &#123;&#125; 测试这些遍历方式效率的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import java.util.List;import java.util.Iterator;import java.util.LinkedList;import java.util.NoSuchElementException;/* * @desc 测试LinkedList的几种遍历方式和效率 * * @author skywang */public class LinkedListThruTest &#123; public static void main(String[] args) &#123; // 通过Iterator遍历LinkedList iteratorLinkedListThruIterator(getLinkedList()) ; // 通过快速随机访问遍历LinkedList iteratorLinkedListThruForeach(getLinkedList()) ; // 通过for循环的变种来访问遍历LinkedList iteratorThroughFor2(getLinkedList()) ; // 通过PollFirst()遍历LinkedList iteratorThroughPollFirst(getLinkedList()) ; // 通过PollLast()遍历LinkedList iteratorThroughPollLast(getLinkedList()) ; // 通过removeFirst()遍历LinkedList iteratorThroughRemoveFirst(getLinkedList()) ; // 通过removeLast()遍历LinkedList iteratorThroughRemoveLast(getLinkedList()) ; &#125; private static LinkedList getLinkedList() &#123; LinkedList llist = new LinkedList(); for (int i=0; i&lt;100000; i++) llist.addLast(i); return llist; &#125; /** * 通过快迭代器遍历LinkedList */ private static void iteratorLinkedListThruIterator(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext();) iter.next(); // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorLinkedListThruIterator：" + interval+" ms"); &#125; /** * 通过快速随机访问遍历LinkedList */ private static void iteratorLinkedListThruForeach(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); int size = list.size(); for (int i=0; i&lt;size; i++) &#123; list.get(i); &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorLinkedListThruForeach：" + interval+" ms"); &#125; /** * 通过另外一种for循环来遍历LinkedList */ private static void iteratorThroughFor2(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); for (Integer integ:list) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughFor2：" + interval+" ms"); &#125; /** * 通过pollFirst()来遍历LinkedList */ private static void iteratorThroughPollFirst(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); while(list.pollFirst() != null) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughPollFirst：" + interval+" ms"); &#125; /** * 通过pollLast()来遍历LinkedList */ private static void iteratorThroughPollLast(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); while(list.pollLast() != null) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughPollLast：" + interval+" ms"); &#125; /** * 通过removeFirst()来遍历LinkedList */ private static void iteratorThroughRemoveFirst(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); try &#123; while(list.removeFirst() != null) ; &#125; catch (NoSuchElementException e) &#123; &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughRemoveFirst：" + interval+" ms"); &#125; /** * 通过removeLast()来遍历LinkedList */ private static void iteratorThroughRemoveLast(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); try &#123; while(list.removeLast() != null) ; &#125; catch (NoSuchElementException e) &#123; &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughRemoveLast：" + interval+" ms"); &#125;&#125; 执行结果： 1234567iteratorLinkedListThruIterator：8 msiteratorLinkedListThruForeach：3724 msiteratorThroughFor2：5 msiteratorThroughPollFirst：8 msiteratorThroughPollLast：6 msiteratorThroughRemoveFirst：2 msiteratorThroughRemoveLast：2 ms 由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用第3种遍历方式。无论如何，千万不要通过随机访问去遍历LinkedList！ 第5部分 LinkedList示例下面通过一个示例来学习如何使用LinkedList的常用API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import java.util.List;import java.util.Iterator;import java.util.LinkedList;import java.util.NoSuchElementException;/* * @desc LinkedList测试程序。 * * @author skywang * @email kuiwu-wang@163.com */public class LinkedListTest &#123; public static void main(String[] args) &#123; // 测试LinkedList的API testLinkedListAPIs() ; // 将LinkedList当作 LIFO(后进先出)的堆栈 useLinkedListAsLIFO(); // 将LinkedList当作 FIFO(先进先出)的队列 useLinkedListAsFIFO(); &#125; /* * 测试LinkedList中部分API */ private static void testLinkedListAPIs() &#123; String val = null; //LinkedList llist; //llist.offer("10"); // 新建一个LinkedList LinkedList llist = new LinkedList(); //---- 添加操作 ---- // 依次添加1,2,3 llist.add("1"); llist.add("2"); llist.add("3"); // 将“4”添加到第一个位置 llist.add(1, "4"); System.out.println("\nTest \"addFirst(), removeFirst(), getFirst()\""); // (01) 将“10”添加到第一个位置。 失败的话，抛出异常！ llist.addFirst("10"); System.out.println("llist:"+llist); // (02) 将第一个元素删除。 失败的话，抛出异常！ System.out.println("llist.removeFirst():"+llist.removeFirst()); System.out.println("llist:"+llist); // (03) 获取第一个元素。 失败的话，抛出异常！ System.out.println("llist.getFirst():"+llist.getFirst()); System.out.println("\nTest \"offerFirst(), pollFirst(), peekFirst()\""); // (01) 将“10”添加到第一个位置。 返回true。 llist.offerFirst("10"); System.out.println("llist:"+llist); // (02) 将第一个元素删除。 失败的话，返回null。 System.out.println("llist.pollFirst():"+llist.pollFirst()); System.out.println("llist:"+llist); // (03) 获取第一个元素。 失败的话，返回null。 System.out.println("llist.peekFirst():"+llist.peekFirst()); System.out.println("\nTest \"addLast(), removeLast(), getLast()\""); // (01) 将“20”添加到最后一个位置。 失败的话，抛出异常！ llist.addLast("20"); System.out.println("llist:"+llist); // (02) 将最后一个元素删除。 失败的话，抛出异常！ System.out.println("llist.removeLast():"+llist.removeLast()); System.out.println("llist:"+llist); // (03) 获取最后一个元素。 失败的话，抛出异常！ System.out.println("llist.getLast():"+llist.getLast()); System.out.println("\nTest \"offerLast(), pollLast(), peekLast()\""); // (01) 将“20”添加到第一个位置。 返回true。 llist.offerLast("20"); System.out.println("llist:"+llist); // (02) 将第一个元素删除。 失败的话，返回null。 System.out.println("llist.pollLast():"+llist.pollLast()); System.out.println("llist:"+llist); // (03) 获取第一个元素。 失败的话，返回null。 System.out.println("llist.peekLast():"+llist.peekLast()); // 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！ llist.set(2, "300"); // 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！ System.out.println("\nget(3):"+llist.get(2)); // ---- toArray(T[] a) ---- // 将LinkedList转行为数组 String[] arr = (String[])llist.toArray(new String[0]); for (String str:arr) System.out.println("str:"+str); // 输出大小 System.out.println("size:"+llist.size()); // 清空LinkedList llist.clear(); // 判断LinkedList是否为空 System.out.println("isEmpty():"+llist.isEmpty()+"\n"); &#125; /** * 将LinkedList当作 LIFO(后进先出)的堆栈 */ private static void useLinkedListAsLIFO() &#123; System.out.println("\nuseLinkedListAsLIFO"); // 新建一个LinkedList LinkedList stack = new LinkedList(); // 将1,2,3,4添加到堆栈中 stack.push("1"); stack.push("2"); stack.push("3"); stack.push("4"); // 打印“栈” System.out.println("stack:"+stack); // 删除“栈顶元素” System.out.println("stack.pop():"+stack.pop()); // 取出“栈顶元素” System.out.println("stack.peek():"+stack.peek()); // 打印“栈” System.out.println("stack:"+stack); &#125; /** * 将LinkedList当作 FIFO(先进先出)的队列 */ private static void useLinkedListAsFIFO() &#123; System.out.println("\nuseLinkedListAsFIFO"); // 新建一个LinkedList LinkedList queue = new LinkedList(); // 将10,20,30,40添加到队列。每次都是插入到末尾 queue.add("10"); queue.add("20"); queue.add("30"); queue.add("40"); // 打印“队列” System.out.println("queue:"+queue); // 删除(队列的第一个元素) System.out.println("queue.remove():"+queue.remove()); // 读取(队列的第一个元素) System.out.println("queue.element():"+queue.element()); // 打印“队列” System.out.println("queue:"+queue); &#125;&#125; 运行结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Test &quot;addFirst(), removeFirst(), getFirst()&quot;llist:[10, 1, 4, 2, 3]llist.removeFirst():10llist:[1, 4, 2, 3]llist.getFirst():1Test &quot;offerFirst(), pollFirst(), peekFirst()&quot;llist:[10, 1, 4, 2, 3]llist.pollFirst():10llist:[1, 4, 2, 3]llist.peekFirst():1Test &quot;addLast(), removeLast(), getLast()&quot;llist:[1, 4, 2, 3, 20]llist.removeLast():20llist:[1, 4, 2, 3]llist.getLast():3Test &quot;offerLast(), pollLast(), peekLast()&quot;llist:[1, 4, 2, 3, 20]llist.pollLast():20llist:[1, 4, 2, 3]llist.peekLast():3get(3):300str:1str:4str:300str:3size:4isEmpty():trueuseLinkedListAsLIFOstack:[4, 3, 2, 1]stack.pop():4stack.peek():3stack:[3, 2, 1]useLinkedListAsFIFOqueue:[10, 20, 30, 40]queue.remove():10queue.element():20queue:[20, 30, 40]]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedList</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记（一）]]></title>
    <url>%2F2018%2F09%2F19%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[随机生成20个不重复的小写字母并进行排序，排序方式为倒序。 123456789101112131415161718192021222324252627private static char getRamdomChar(Random rdm)&#123; int i = Math.abs(rdm.nextInt())%26+97;//产生97到122的随机数a-z值; i = i%26; i=i+97; return (char)i; &#125; public static void main(String[] args) &#123; TreeSet&lt;Character&gt;tset = new TreeSet&lt;Character&gt;(new Comparator&lt;Character&gt;() &#123; @Override public int compare(Character o1, Character o2) &#123; if(o1&gt;o2) return -1; else if(o1&lt;o2) return 1; return 0; &#125; &#125;);Random rdm = new Random(); while(tset.size() &lt; 20)&#123; tset.add(getRamdomChar(rdm)); &#125; for(Object aa:tset.toArray())&#123; System. out .print(aa); &#125; &#125; 得分点： 实现随机产生字母 （6分） 实现去重 （5分） 实现排序 （5分） 使用treeset的排序和去重特性 （4分），其它实现方式酌情给分（可参考算法的性能） For Java 随机数的生成int randNumber =rand.nextInt(MAX - MIN + 1) + MIN; // randNumber 将被赋值为一个 MIN 和 MAX 范围内的随机数 ArrayList、LinkedList、Vector的区别Arraylist和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以插入数据慢，查找有下标，所以查询数据快，Vector由于使用了synchronized方法-线程安全，所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项前后项即可，插入数据较快。 线性表，链表，哈希表是常用的数据结构，在进行java开发时，JDK已经为我们提供了一系列相应的类实现基本的数据结构，这些结构均在java.util包中， collection ├List│├LinkedList│├ArrayList│└Vector│ └Stack└Set Map├Hashtable├HashMap└WeakHashMap 由Collection接口派生的两个接口是List和Set List接口 List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。和下面要提到的Set不同，List允许有相同的元素。 除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。 实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。 ArrayList类 ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。 每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 Vector类 Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 Stack 类 Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 Hashtable是同步的。 Hashtable类 Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。 添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。 HashMap类 HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。 WeakHashMap类 WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。 总结 如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。 要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。 尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。 super和this的异同： super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。 Java的数据类型 计算时的自动类型转换 所有的byte,short,char型的值将被提升为int型； 如果有一个操作数是long型，计算结果是long型； 如果有一个操作数是float型，计算结果是float型； 如果有一个操作数是double型，计算结果是double型； Java内部类在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。 1.成员内部类 成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： 12345678910111213class Circle &#123; double radius = 0; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println("drawshape"); &#125; &#125;&#125; 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 1234567891011121314class Circle &#123; private double radius = 0; public static int count =1; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 &#125; &#125;&#125; 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问： 12外部类.this.成员变量外部类.this.成员方法 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： 123456789101112131415161718class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 &#125; &#125;&#125; 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125; class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 2.局部内部类 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 123456789101112131415161718class People&#123; public People() &#123; &#125;&#125; class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 3.匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码： 1234567891011121314151617scan_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125; &#125;); history_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125; &#125;); 这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的： 12345678new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125; &#125; 就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。 123456789101112131415161718192021private void setListener()&#123; scan_bt.setOnClickListener(new Listener1()); history_bt.setOnClickListener(new Listener2());&#125; class Listener1 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; class Listener2 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 4.静态内部类 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125; class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器： 123final com.cxh.test2.Outter this$0;public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter); 从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。 具体可看该文章: https://www.cnblogs.com/dolphin0520/p/3811445.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环境变量设置]]></title>
    <url>%2F2018%2F09%2F03%2F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Windows环境变量列表编辑方式设置最近笔者在修改windows系统环境变量的时候遇到一个问题，在编辑环境变量的时候本来是列表模式，但是点击文本编辑模式后就回不去列表编辑模式，这样在添加和修改某个变量的时候找起来比较麻烦。经过在网上不断的查找终于找了解决的方法，希望可以帮到有类似问题的同学。 方法其实很简单，只要保证每个变量的第一个值是盘符开头的，不带有其他符号如 % 等即可。]]></content>
      <categories>
        <category>配置备忘录</category>
      </categories>
      <tags>
        <tag>windows配置</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习日志（一)]]></title>
    <url>%2F2018%2F07%2F12%2Fdiary-2018-07-12%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>实习日志</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>maven</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.以下为使用hexo的一些简单的命令 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo配置及使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
